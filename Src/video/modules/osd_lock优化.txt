osd_lock 锁职责分析报告
? 核心问题：锁的职责混乱
原始代码和重构代码对 osd_lock 的使用存在严重不一致的问题：
1. 原始代码中的使用模式
函数	位置	加锁	解锁	保护范围
VideoSetTitle	video.c:2743	?	?	OSD buffer + 绘制操作
VideoSetLogo	video.c:2978	?	?	Logo buffer + 绘制操作
osd_destroy	video.c:4031	?	?	OSD销毁操作
VideoSetFormat	video.c:1234	?	?	只有unlock，说明外层持锁
编码器重配置	video.c:多处	?	? (多处)	只有unlock，说明外层持锁
原始代码设计意图：
osd_lock 保护 OSD/Logo的配置和绘制操作
BUT 在 VideoSetFormat 等编码器重配置场景中，锁的范围超出了OSD模块，覆盖了整个编码通道重配置流程
2. 重构代码中的问题
? 问题1：_set_title() 中孤立的 unlock
// video_osd.c:795-819
int _set_title()
{
    VideoOSD_Create();
    pthread_mutex_unlock(&osd_lock);  // ← 没有对应的 lock！
    
    for (int i = 0; i < TD_OSD_MAX_NUM; i++) {
        ret |= VideoOSD_SetTitle(0, &pParam);  // ← 这个内部又有lock/unlock
    }
    return ret;
}
这里的 unlock 说明：
外层调用者应该已经加锁（video_encoder.c:1063 调用时）
但实际上 VideoEncoder_UpdateChannelConfig 并没有加锁！
? 问题2：VideoEncoder_UpdateChannelConfig 中的多处 unlock
// video_encoder.c:936, 943, 951... (多处)
int VideoEncoder_UpdateChannelConfig(...)
{
    // 没有 lock！
    
    if (NULL == info || channel >= EncCnt) {
        pthread_mutex_unlock(&osd_lock);  // ← Line 936
        return ret;
    }
    
    if (0 == info->frame_count) {
        pthread_mutex_unlock(&osd_lock);  // ← Line 943
        return ret;
    }
    
    // ... 多处unlock，但开头没有lock
}
这表明：调用 VideoEncoder_UpdateChannelConfig 的外层函数应该已经持有锁！
3. 锁的真正职责（推测）
根据原始代码的使用模式，osd_lock 的设计意图应该是：
职责A：保护OSD/Logo的绘制操作（明确）
VideoSetTitle 内部：lock → OSD操作 → unlock
VideoSetLogo 内部：lock → Logo操作 → unlock
VideoOSD_Destroy 内部：lock → 销毁操作 → unlock
职责B：保护编码器重配置期间的OSD一致性（隐含）
在 VideoSetFormat / VideoEncoder_UpdateChannelConfig 期间：
外层加锁 → 重配置编码通道 → OSD/Logo重新创建 → 外层解锁
目的：防止在编码通道重配置期间，有其他线程尝试修改OSD
4. 建议的修复方案
方案A：明确锁的两层职责（推荐）
OSD模块内部操作：由各自函数内部管理锁
VideoOSD_SetTitle：内部 lock/unlock ?
VideoOSD_SetLogo：内部 lock/unlock ?
VideoOSD_Destroy：内部 lock/unlock ?
编码器重配置：由外层统一持锁
VideoSetFormat / VideoEncoder_UpdateChannelConfig 开头加锁
调用 _set_title() / _set_logo() 等（这些函数不再内部加锁）
结尾解锁
方案B：简化职责，分离锁（更清晰，但改动大）
创建 encoder_config_lock：保护编码器重配置
保留 osd_lock：仅保护OSD绘制操作
两把锁互不干扰
5. 当前紧急修复
立即修复 _set_title() 和 VideoEncoder_UpdateChannelConfig 的锁问题：
在 VideoEncoder_UpdateChannelConfig 开头添加 pthread_mutex_lock(&osd_lock);
删除 _set_title() 中的孤立 unlock
VideoOSD_SetTitle / VideoOSD_SetLogo 保留内部的 lock/unlock（因为它们也可能被单独调用）
总结
? 当前问题：osd_lock 职责不清晰，加锁/解锁配对混乱
?? 根本原因：锁同时承担了"OSD操作保护"和"编码器重配置保护"两个职责
? 建议：明确锁的两层使用场景，修复配对问题
你需要我直接修复这些问题吗？还是你想先确认修复方案？